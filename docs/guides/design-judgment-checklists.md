# 設計判断チェックリスト

Advanced レッスンから抽出した設計判断の観点。コードレビュー、面談、セルフチェックに活用できます。

---

## 1. パフォーマンス最適化

**基本原則**: 計測 → 仮説 → 最適化の順。早すぎる最適化は害。

### 最適化前のチェック

- [ ] **計測したか？** DevToolsで実際に遅いことを確認した
- [ ] **ボトルネック特定**：どのコンポーネントが重いか把握している
- [ ] **仮説がある**：「〜が原因で〜ms遅い」と言える

### 最適化手法の選択

| 状況                                 | 手法                              |
| ------------------------------------ | --------------------------------- |
| 子に渡すコールバック関数             | useCallback                       |
| 重い計算結果                         | useMemo                           |
| 子コンポーネント全体の再レンダリング | React.memo                        |
| 長いリスト（100件以上）              | 仮想化（@tanstack/react-virtual） |

### やりすぎ警告サイン

- [ ] 計測せずにuseMemo/useCallbackを追加していないか
- [ ] 「念のため」でReact.memoを全部につけていないか
- [ ] 可読性を犠牲にしていないか

---

## 2. TypeScript型設計

**基本原則**: 型は「誰を守るためか」を明確に。

### Props型チェック

- [ ] **公開APIとしてのProps**: 呼び出し側のミスを防ぐ型になっているか
- [ ] **必須/オプション**: デフォルト値があるものはオプショナルか
- [ ] **Discriminated Union**: 状態に応じて異なるPropsを持つ場合に使っているか

### 型の厳密さ判断

| 境界                          | 厳密度                           |
| ----------------------------- | -------------------------------- |
| 外部入力（API、ユーザー入力） | 厳密に検証（unknown + 型ガード） |
| 公開コンポーネントのProps     | 厳密に型定義                     |
| 内部ロジック                  | 適度に緩く（推論に任せる）       |

### やりすぎ警告サイン

- [ ] `as unknown as T` が多用されていないか
- [ ] 型定義が実装より長くなっていないか
- [ ] Generic が3層以上ネストしていないか

---

## 3. テスト設計

**基本原則**: テストの目的は「安心して変更するため」。

### テストを書く前のチェック

- [ ] **何を守っている？** 壊れたら誰が困るか答えられる
- [ ] **他でカバー済み？** 重複していないか
- [ ] **実装依存していない？** 実装変更で壊れないか

### テストレイヤーの選択

| レイヤー    | 対象                 | 例                         |
| ----------- | -------------------- | -------------------------- |
| Unit        | 純粋なロジック       | validateEmail, formatPrice |
| Integration | コンポーネント連携   | LoginForm, UserList        |
| E2E         | クリティカルパスのみ | ログイン→購入完了          |

### やりすぎ警告サイン

- [ ] カバレッジ100%を目指していないか
- [ ] 静的テキストの存在をテストしていないか
- [ ] E2Eでロジックの全パターンを検証していないか

---

## 4. 状態管理設計

**基本原則**: 状態は使う場所に一番近いところで管理。Global は最後の手段。

### スコープ判断フロー

```
1. この状態を使うコンポーネントは1つだけ？
   → Yes: useState（Local）

2. 親子関係で共有できる？
   → Yes: props / 状態の持ち上げ（Lifted）

3. 更新頻度は低い？（テーマ、認証など）
   → Yes: Context

4. 更新頻度が高い / 複雑な状態遷移？
   → Yes: 外部ストア（Zustand, Jotai等）
```

### 状態の寿命チェック

- [ ] **一時的**（モーダル開閉）→ useState
- [ ] **ページ内**（フォーム入力）→ useState / useReducer
- [ ] **セッション**（カート、ログイン）→ Context / 外部ストア
- [ ] **永続**（設定、履歴）→ localStorage + 外部ストア

### やりすぎ警告サイン

- [ ] モーダルの開閉がグローバルストアにないか
- [ ] 1つのReducerに50種類以上のアクションがないか
- [ ] UIの状態とドメインデータが混在していないか

---

## クイックリファレンス

### レビューで使える質問

**パフォーマンス**

- 「これ、計測した結果ですか？」
- 「useMemoなしだとどのくらい遅いですか？」

**TypeScript**

- 「この型は誰を守っていますか？」
- 「asを使わずに書けますか？」

**テスト**

- 「このテストが落ちたら、何が壊れていますか？」
- 「実装を変えたらこのテスト壊れますか？」

**状態管理**

- 「この状態は誰が使いますか？」
- 「いつ消えるべきですか？」
- 「Localで済みませんか？」

---

## 関連レッスン

- [react-performance](/lessons/react-performance) - パフォーマンス最適化
- [typescript-with-react](/lessons/typescript-with-react) - 型設計
- [testing-basics](/lessons/testing-basics) - テスト設計
- [state-management-patterns](/lessons/state-management-patterns) - 状態管理
