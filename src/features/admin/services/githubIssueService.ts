/**
 * GitHub Issue Service for Lesson Improvement Automation
 *
 * P3-2.3: Automatically creates GitHub Issues for lessons needing improvement.
 *
 * ## ç™ºç«æ¡ä»¶ï¼ˆspec-lockï¼‰
 * - originCount >= 5
 * - improvementHint !== null
 * - hintType !== 'LOW_SAMPLE'
 * - åŒä¸€ lesson + hintType ã® Issue ãŒ Open ã§å­˜åœ¨ã—ãªã„
 */

import { isMockMode } from '@/lib/supabase/client';
import type { HintType } from '@/features/metrics';

// Environment variables for GitHub API
const GITHUB_TOKEN = import.meta.env.VITE_GITHUB_TOKEN;
const GITHUB_OWNER = import.meta.env.VITE_GITHUB_OWNER;
const GITHUB_REPO = import.meta.env.VITE_GITHUB_REPO;

const ISSUE_LABEL_PREFIX = 'lesson-improvement';
const METRICS_LABEL = 'metrics';

/**
 * Parameters for creating a lesson improvement issue
 */
export interface CreateIssueParams {
  lessonSlug: string;
  lessonTitle: string;
  hintType: HintType;
  hintMessage: string;
  followUpRate: number;
  originCount: number;
  baselineWindowDays?: number;
  baselineSnapshotAtUtc?: string;
}

/**
 * Created issue info
 */
export interface CreatedIssue {
  number: number;
  url: string;
  title: string;
}

/**
 * Result type for API calls
 */
export interface IssueResult<T> {
  data: T | null;
  error: string | null;
}

/**
 * Open issue info for duplicate checking
 */
export interface OpenIssue {
  number: number;
  url: string;
  title: string;
  labels: string[];
}

// Mock storage for testing
let mockCreatedIssues: CreatedIssue[] = [];
let mockOpenIssues: OpenIssue[] = [];
let mockClosedIssues: OpenIssue[] = [];

/**
 * Set mock open issues for testing
 */
export function setMockOpenIssues(issues: OpenIssue[]): void {
  mockOpenIssues = [...issues];
}

/**
 * Set mock closed issues for testing
 */
export function setMockClosedIssues(issues: OpenIssue[]): void {
  mockClosedIssues = [...issues];
}

/**
 * Get mock created issues for testing
 */
export function getMockCreatedIssues(): CreatedIssue[] {
  return [...mockCreatedIssues];
}

/**
 * Reset mock data
 */
export function resetMockIssueData(): void {
  mockCreatedIssues = [];
  mockOpenIssues = [];
  mockClosedIssues = [];
}

/**
 * Get hint reason text for issue body
 */
function getHintReasonText(hintType: HintType): string {
  const reasons: Record<HintType, string> = {
    LOW_SAMPLE: 'ã‚µãƒ³ãƒ—ãƒ«æ•°ãŒå°‘ãªã„ãŸã‚åˆ¤æ–­ä¿ç•™ä¸­ã§ã™ã€‚',
    NEXT_LESSON_WEAK:
      'Follow-upç‡ãŒ20%æœªæº€ã§ã€ã‹ã¤ next_lesson_opened ãŒ0ä»¶ã§ã™ã€‚æ¬¡ã®ãƒ¬ãƒƒã‚¹ãƒ³ã¸ã®å°ç·šãŒå¼±ã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚',
    CTA_MISSING:
      'review_startedã€quiz_startedã€note_created ãŒã™ã¹ã¦0ä»¶ã§ã™ã€‚å¾©ç¿’ãƒ»ã‚¯ã‚¤ã‚ºãƒ»ãƒãƒ¼ãƒˆã¸ã®å°ç·šãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚',
    LOW_ENGAGEMENT:
      'Follow-upç‡ãŒ30%æœªæº€ã§ã™ã€‚å†…å®¹ç†è§£å¾Œã®è¡Œå‹•ã«ã¤ãªãŒã£ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚',
  };
  return reasons[hintType];
}

/**
 * Get recommended actions for issue body
 */
function getRecommendedActions(hintType: HintType): string {
  const actions: Record<HintType, string> = {
    LOW_SAMPLE: '- ã‚ˆã‚Šå¤šãã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ãƒ¬ãƒƒã‚¹ãƒ³ã‚’é–²è¦§ã—ã¦ã‚‚ã‚‰ã†æ–½ç­–ã‚’æ¤œè¨',
    NEXT_LESSON_WEAK: `- Next Lessons ã®é–¢é€£ã‚’è¿½åŠ 
- ãƒ¬ãƒƒã‚¹ãƒ³æœ«å°¾ã«ã€Œæ¬¡ã¯â—‹â—‹ã‚’èª­ã‚€ã€æ–‡è¨€ã‚’è¿½åŠ 
- prerequisites / é–¢é€£ãƒ¬ãƒƒã‚¹ãƒ³ã®è¨­å®šã‚’ç¢ºèª`,
    CTA_MISSING: `- ã€Œã“ã®å†…å®¹ã‚’ãƒãƒ¼ãƒˆã«ã¾ã¨ã‚ã‚ˆã†ã€CTAã‚’è¿½åŠ 
- ã‚¯ã‚¤ã‚ºãƒ»å¾©ç¿’ãƒœã‚¿ãƒ³ã‚’æœ¬æ–‡ä¸‹ã«é…ç½®
- Exercises ã®æœ€å¾Œã«è¡Œå‹•ã‚’ä¿ƒã™æ–‡è¨€ã‚’è¿½åŠ `,
    LOW_ENGAGEMENT: `- Example ã‚’1ã¤è¿½åŠ ï¼ˆã‚³ãƒ”ãƒšã§å‹•ãã‚‚ã®ï¼‰
- Pitfalls ã‚’å®Ÿä¾‹ãƒ™ãƒ¼ã‚¹ã«æ›¸ãç›´ã™
- Exercises ã‚’3æ®µéšæ§‹æˆï¼ˆæ˜“â†’ä¸­â†’é›£ï¼‰ã«ä¿®æ­£`,
  };
  return actions[hintType];
}

/**
 * Build issue body from params
 */
function buildIssueBody(params: CreateIssueParams): string {
  const {
    lessonTitle,
    lessonSlug,
    hintType,
    followUpRate,
    originCount,
    baselineWindowDays = 30,
    baselineSnapshotAtUtc = new Date().toISOString().split('T')[0] + 'T00:00:00Z',
  } = params;

  return `## ğŸ“‰ æ¤œçŸ¥ã•ã‚ŒãŸæ”¹å–„ãƒ’ãƒ³ãƒˆ

- Lesson: **${lessonTitle}**
- Slug: \`${lessonSlug}\`
- Hint Type: **${hintType}**
- Follow-up Rate: **${followUpRate}%**
- Origin Count: ${originCount}

---

## ğŸ” åˆ¤å®šç†ç”±

${getHintReasonText(hintType)}

---

## ğŸ›  æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

${getRecommendedActions(hintType)}

---

## âœ… æ”¹å–„ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] Example ã‚’è¿½åŠ  / æ”¹å–„
- [ ] æ¬¡ã®ãƒ¬ãƒƒã‚¹ãƒ³å°ç·šã‚’è¿½åŠ 
- [ ] CTAï¼ˆå¾©ç¿’ / ã‚¯ã‚¤ã‚º / ãƒãƒ¼ãƒˆï¼‰ã‚’é…ç½®
- [ ] validate:lessons ã‚’é€šé
- [ ] æ”¹å–„å¾Œ 7 æ—¥ã§ followUpRate ã‚’å†ç¢ºèª

---

## ğŸ“Š æ¤œè¨¼æŒ‡æ¨™ï¼ˆæ”¹å–„å¾Œï¼‰

- Follow-up Rate ãŒ **+10%ä»¥ä¸Š**
- next_lesson_opened / review / quiz / note ã®ã„ãšã‚Œã‹ãŒå¢—åŠ 

---

_Auto-generated by P3-2.3 Lesson Improvement Automation_

---
lesson_slug: ${lessonSlug}
hint_type: ${hintType}
baseline_window_days: ${baselineWindowDays}
baseline_snapshot_at_utc: ${baselineSnapshotAtUtc}
origin_count: ${originCount}
follow_up_rate: ${followUpRate}
---`;
}

/**
 * Build issue title
 * @note slug is included in parentheses for duplicate detection
 */
function buildIssueTitle(lessonSlug: string, lessonTitle: string, hintType: HintType): string {
  return `[Lesson Improvement] ${lessonTitle} (${lessonSlug}) - ${hintType}`;
}

/**
 * Get labels for the issue
 */
function getIssueLabels(lessonSlug: string, hintType: HintType): string[] {
  return [ISSUE_LABEL_PREFIX, METRICS_LABEL, `hint:${hintType}`, `lesson:${lessonSlug}`];
}

/**
 * Check if an issue with the same lesson and hint type already exists
 *
 * @spec-lock åŒä¸€ lesson + hintType ã® Issue ãŒ Open ã§å­˜åœ¨ã—ãªã„
 */
export async function isDuplicateIssue(
  lessonSlug: string,
  hintType: HintType
): Promise<IssueResult<boolean>> {
  // Mock mode
  if (isMockMode) {
    const expectedTitle = `[Lesson Improvement]`;
    const hintLabel = `hint:${hintType}`;
    const isDuplicate = mockOpenIssues.some(
      (issue) =>
        issue.title.includes(expectedTitle) &&
        issue.title.includes(lessonSlug) &&
        issue.labels.includes(hintLabel)
    );
    return { data: isDuplicate, error: null };
  }

  // Check for required env vars
  if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
    return {
      data: null,
      error: 'GitHub API credentials not configured',
    };
  }

  try {
    const hintLabel = `hint:${hintType}`;
    const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/issues?state=open&labels=${ISSUE_LABEL_PREFIX},${hintLabel}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        Accept: 'application/vnd.github+json',
        Authorization: `Bearer ${GITHUB_TOKEN}`,
        'X-GitHub-Api-Version': '2022-11-28',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        data: null,
        error: `Failed to check issues: ${response.status} ${errorText}`,
      };
    }

    const issues = await response.json();

    // Check if any issue contains the lesson slug in title
    const isDuplicate = issues.some((issue: { title: string }) => issue.title.includes(lessonSlug));

    return { data: isDuplicate, error: null };
  } catch (err) {
    return {
      data: null,
      error: err instanceof Error ? err.message : 'Unknown error occurred',
    };
  }
}

/**
 * List open issues for a specific lesson
 */
export async function listOpenIssuesByLesson(
  lessonSlug: string
): Promise<IssueResult<OpenIssue[]>> {
  // Mock mode
  if (isMockMode) {
    const filtered = mockOpenIssues.filter((issue) => issue.title.includes(lessonSlug));
    return { data: filtered, error: null };
  }

  // Check for required env vars
  if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
    return {
      data: null,
      error: 'GitHub API credentials not configured',
    };
  }

  try {
    const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/issues?state=open&labels=${ISSUE_LABEL_PREFIX}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        Accept: 'application/vnd.github+json',
        Authorization: `Bearer ${GITHUB_TOKEN}`,
        'X-GitHub-Api-Version': '2022-11-28',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        data: null,
        error: `Failed to list issues: ${response.status} ${errorText}`,
      };
    }

    const issues = await response.json();

    const filtered: OpenIssue[] = issues
      .filter((issue: { title: string }) => issue.title.includes(lessonSlug))
      .map(
        (issue: {
          number: number;
          html_url: string;
          title: string;
          labels: { name: string }[];
        }) => ({
          number: issue.number,
          url: issue.html_url,
          title: issue.title,
          labels: issue.labels.map((l) => l.name),
        })
      );

    return { data: filtered, error: null };
  } catch (err) {
    return {
      data: null,
      error: err instanceof Error ? err.message : 'Unknown error occurred',
    };
  }
}

/**
 * Create a lesson improvement issue
 *
 * @spec-lock
 * - originCount >= 5
 * - hintType !== 'LOW_SAMPLE'
 * - é‡è¤‡ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨
 */
export async function createIssue(params: CreateIssueParams): Promise<IssueResult<CreatedIssue>> {
  const { lessonSlug, lessonTitle, hintType, originCount } = params;

  // Validate preconditions
  if (originCount < 5) {
    return {
      data: null,
      error: 'Cannot create issue: originCount must be >= 5',
    };
  }

  if (hintType === 'LOW_SAMPLE') {
    return {
      data: null,
      error: 'Cannot create issue for LOW_SAMPLE hint type',
    };
  }

  // Mock mode
  if (isMockMode) {
    const title = buildIssueTitle(lessonSlug, lessonTitle, hintType);
    const issue: CreatedIssue = {
      number: mockCreatedIssues.length + 1,
      url: `https://github.com/mock/repo/issues/${mockCreatedIssues.length + 1}`,
      title,
    };
    mockCreatedIssues.push(issue);

    // Also add to open issues for duplicate detection
    mockOpenIssues.push({
      ...issue,
      labels: getIssueLabels(lessonSlug, hintType),
    });

    return { data: issue, error: null };
  }

  // Check for required env vars
  if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
    return {
      data: null,
      error: 'GitHub API credentials not configured',
    };
  }

  try {
    const title = buildIssueTitle(lessonSlug, lessonTitle, hintType);
    const body = buildIssueBody(params);
    const labels = getIssueLabels(lessonSlug, hintType);

    const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/issues`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        Accept: 'application/vnd.github+json',
        Authorization: `Bearer ${GITHUB_TOKEN}`,
        'X-GitHub-Api-Version': '2022-11-28',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title,
        body,
        labels,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        data: null,
        error: `Failed to create issue: ${response.status} ${errorText}`,
      };
    }

    const created = await response.json();

    return {
      data: {
        number: created.number,
        url: created.html_url,
        title: created.title,
      },
      error: null,
    };
  } catch (err) {
    return {
      data: null,
      error: err instanceof Error ? err.message : 'Unknown error occurred',
    };
  }
}

/**
 * Check if issue creation is allowed for given params
 *
 * @spec-lock ç™ºç«æ¡ä»¶ãƒã‚§ãƒƒã‚¯
 */
export function canCreateIssue(originCount: number, hintType: HintType | null): boolean {
  if (originCount < 5) return false;
  if (hintType === null) return false;
  if (hintType === 'LOW_SAMPLE') return false;
  return true;
}

/**
 * Improvement tracker item with baseline and current metrics
 */
export interface ImprovementTrackerItem {
  lessonSlug: string;
  hintType: HintType;
  baselineRate: number;
  baselineOriginCount: number;
  issueNumber: number;
  issueUrl: string;
}

/**
 * Parse baseline metrics from issue body
 *
 * Extracts baseline data from markdown format:
 * - Follow-up Rate: **XX%**
 * - Origin Count: XX
 * Also tries to parse from metadata section at the end
 */
function parseBaselineFromIssueBody(body: string): {
  baselineRate: number;
  baselineOriginCount: number;
} {
  // Try to parse from metadata section first (more reliable)
  const metadataRateMatch = body.match(/follow_up_rate:\s*(\d+)/);
  const metadataCountMatch = body.match(/origin_count:\s*(\d+)/);

  if (metadataRateMatch && metadataCountMatch) {
    return {
      baselineRate: parseInt(metadataRateMatch[1], 10),
      baselineOriginCount: parseInt(metadataCountMatch[1], 10),
    };
  }

  // Fallback to parsing from main content
  const rateMatch = body.match(/Follow-up Rate:\s*\*\*(\d+)%\*\*/);
  const countMatch = body.match(/Origin Count:\s*(\d+)/);

  return {
    baselineRate: rateMatch ? parseInt(rateMatch[1], 10) : 0,
    baselineOriginCount: countMatch ? parseInt(countMatch[1], 10) : 0,
  };
}

/**
 * List all open improvement issues with their baseline metrics
 *
 * This function retrieves all open issues with the lesson-improvement label
 * and extracts baseline metrics from the issue body.
 *
 * @returns Array of improvement tracker items
 */
export async function listAllOpenImprovementIssues(): Promise<
  IssueResult<ImprovementTrackerItem[]>
> {
  // Mock mode
  if (isMockMode) {
    const trackerItems: ImprovementTrackerItem[] = mockOpenIssues
      .filter((issue) => issue.labels.includes(ISSUE_LABEL_PREFIX))
      .map((issue) => {
        // Extract lesson slug from title: "[Lesson Improvement] Title (slug) - HINT_TYPE"
        const slugMatch = issue.title.match(/\(([^)]+)\)/);
        const lessonSlug = slugMatch ? slugMatch[1] : '';

        // Extract hint type from labels
        const hintLabel = issue.labels.find((label) => label.startsWith('hint:'));
        const hintType = (hintLabel?.replace('hint:', '') || 'LOW_ENGAGEMENT') as HintType;

        // For mock mode, use dummy baseline values
        return {
          lessonSlug,
          hintType,
          baselineRate: 15,
          baselineOriginCount: 10,
          issueNumber: issue.number,
          issueUrl: issue.url,
        };
      });

    return { data: trackerItems, error: null };
  }

  // Check for required env vars
  if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
    return {
      data: null,
      error: 'GitHub API credentials not configured',
    };
  }

  try {
    const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/issues?state=open&labels=${ISSUE_LABEL_PREFIX}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        Accept: 'application/vnd.github+json',
        Authorization: `Bearer ${GITHUB_TOKEN}`,
        'X-GitHub-Api-Version': '2022-11-28',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        data: null,
        error: `Failed to list improvement issues: ${response.status} ${errorText}`,
      };
    }

    const issues = await response.json();

    const trackerItems: ImprovementTrackerItem[] = issues.map(
      (issue: {
        number: number;
        html_url: string;
        title: string;
        body: string;
        labels: { name: string }[];
      }) => {
        // Extract lesson slug from title
        const slugMatch = issue.title.match(/\(([^)]+)\)/);
        const lessonSlug = slugMatch ? slugMatch[1] : '';

        // Extract hint type from labels
        const hintLabel = issue.labels.find((label) => label.name.startsWith('hint:'));
        const hintType = (hintLabel?.name.replace('hint:', '') || 'LOW_ENGAGEMENT') as HintType;

        // Parse baseline from issue body
        const { baselineRate, baselineOriginCount } = parseBaselineFromIssueBody(issue.body || '');

        return {
          lessonSlug,
          hintType,
          baselineRate,
          baselineOriginCount,
          issueNumber: issue.number,
          issueUrl: issue.html_url,
        };
      }
    );

    return { data: trackerItems, error: null };
  } catch (err) {
    return {
      data: null,
      error: err instanceof Error ? err.message : 'Unknown error occurred',
    };
  }
}

/**
 * List all closed improvement issues with their baseline metrics
 *
 * This function retrieves all closed issues with the lesson-improvement label
 * and extracts baseline metrics and metadata from the issue body.
 *
 * @returns Array of improvement tracker items for closed issues
 */
export async function listAllClosedImprovementIssues(): Promise<
  IssueResult<ImprovementTrackerItem[]>
> {
  // Mock mode
  if (isMockMode) {
    const trackerItems: ImprovementTrackerItem[] = mockClosedIssues
      .filter((issue) => issue.labels.includes(ISSUE_LABEL_PREFIX))
      .map((issue) => {
        // Extract lesson slug from title: "[Lesson Improvement] Title (slug) - HINT_TYPE"
        const slugMatch = issue.title.match(/\(([^)]+)\)/);
        const lessonSlug = slugMatch ? slugMatch[1] : '';

        // Extract hint type from labels
        const hintLabel = issue.labels.find((label) => label.startsWith('hint:'));
        const hintType = (hintLabel?.replace('hint:', '') || 'LOW_ENGAGEMENT') as HintType;

        // For mock mode, use dummy baseline values
        return {
          lessonSlug,
          hintType,
          baselineRate: 15,
          baselineOriginCount: 10,
          issueNumber: issue.number,
          issueUrl: issue.url,
        };
      });

    return { data: trackerItems, error: null };
  }

  // Check for required env vars
  if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
    return {
      data: null,
      error: 'GitHub API credentials not configured',
    };
  }

  try {
    const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/issues?state=closed&labels=${ISSUE_LABEL_PREFIX}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        Accept: 'application/vnd.github+json',
        Authorization: `Bearer ${GITHUB_TOKEN}`,
        'X-GitHub-Api-Version': '2022-11-28',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        data: null,
        error: `Failed to list closed improvement issues: ${response.status} ${errorText}`,
      };
    }

    const issues = await response.json();

    const trackerItems: ImprovementTrackerItem[] = issues.map(
      (issue: {
        number: number;
        html_url: string;
        title: string;
        body: string;
        labels: { name: string }[];
      }) => {
        // Extract lesson slug from title
        const slugMatch = issue.title.match(/\(([^)]+)\)/);
        const lessonSlug = slugMatch ? slugMatch[1] : '';

        // Extract hint type from labels
        const hintLabel = issue.labels.find((label) => label.name.startsWith('hint:'));
        const hintType = (hintLabel?.name.replace('hint:', '') || 'LOW_ENGAGEMENT') as HintType;

        // Parse baseline from issue body
        const { baselineRate, baselineOriginCount } = parseBaselineFromIssueBody(issue.body || '');

        return {
          lessonSlug,
          hintType,
          baselineRate,
          baselineOriginCount,
          issueNumber: issue.number,
          issueUrl: issue.html_url,
        };
      }
    );

    return { data: trackerItems, error: null };
  } catch (err) {
    return {
      data: null,
      error: err instanceof Error ? err.message : 'Unknown error occurred',
    };
  }
}
